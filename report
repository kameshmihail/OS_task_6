Московский Авиационный Институт
(Национальный Исследовательский Университет)

Факультет информационных технологий и прикладной математики
Кафедра вычислительной математики и программирования


Лабораторная работ №2 по курсу
«Операционные системы»
	

Содержание
1.	Постановка задания
2.	Вариант задания
3.	Общие сведения о программе
4.	Общий метод и алгоритм решения
5.	Демонстрация работы программы
6. 	Выводы

Постановка задания
Реализовать распределенную систему по асинхронной обработке запросов. 
В данной распределенной системе должно существовать 2 вида узлов: «управляющий» и «вычислительный».
Необходимо объединить данные узлы в соответствии с той топологией, которая определена вариантом. 
Связь между узлами необходимо осуществить при помощи технологии очередей сообщений. 
Также в данной системе необходимо предусмотреть проверку доступности узлов в соответствии с вариантом. 


Вариант задания.
Топология 2 – список списков вычислительных узлов.
Тип задания вычислительных узлов 4 – поиск подстроки в строке.
Команда проверки 1 – ping all

Общие сведения о программе
Программа компилируется из одного файла main.c. В данном файле используются заголовочные файлы stdio.h, unistd.h, string.h, stdlib.h. В программе используются следующие системные вызовы:
1.	read – для чтения данных из файла
2.	write – для записи данных в файл
3.	pipe – для создания однонаправленного канала, через который могут общаться два процесса. Системный вызов возвращает два дескриптора файлов. Один для чтения из канала, другой для записи в канал.
4.	fork– для создания дочернего процесса.
5.	close – для закрытия файла.


Общий метод и алгоритм решения.
Для реализации поставленной задачи необходимо:
1.	Используя системный вызов pipe создать 2 канала, по которым будут обмениваться данными два процесса.
2.	Используя системный вызов fork создать дочерний процесс.
3.	В родительском процессе считывать данные cо стандартного потока
4.	Передать данный в дочерний процесс командой write
5.	Считать данные командой read, произвести необходимые вычисления, передать данные обратно
6.	Считать обработанные данные и вывести на экран

Демонстрация работы программы.

1 4
Point lies in quarter 1
1 -4
Point lies in quarter 4
-1 4
Point lies in quarter 2
-1 -4 
Point lies in quarter 3


    2. Описание программы
Был создан класс сообщений, где есть методы отправки и принятия различных сообщений. 
Класс работников содержит в себе параметры связи с сокетами, привязки к определенным портам, а также методы по перестройке или связи и отправке сообщений между собой. 
Основной файл main содержит в себе списки текущих процессов, и пути доступа к ним, при создании он отправляет работникам сообщения о создании и наше мини дерево 
перестраивается в соответствии с конфигурацией. Также тут в другом потоке находится коллектор, он отвечает за асинхронность выполнения задач, собирая данные после их 
завершения по команде update. Внутри каждого работника есть два нода, которые хранят данные о пути выше или ниже от себя, для пересылки им сообщений. 
Все данное действо написано используя 0mq – библиотеку для С++, в которой возможна реализация передачи данных по TCP протоколу.
3.           Выводы
	Очень важно было добиться рационального использования сообщений, отправляя только то, что надо, я мог создать целую структуру для обработки и получения 
	сообщений, но в виду архитектуры передачи текста нефиксированной длинны, размер которой может быть неограничен, мне пришлось разбивать сообщения по классам,
	в зависимости от их использования, что затрудняло отладку, так как в случае ошибки ты не сможешь понять что у тебя находится в сокете пока процесс не прочитает
	его и не обработает, часто в таком случае – неправильно, сломав всю программу. 0mq – как заверяют разработчики очень быстрый способ передачи сообщений, так оно
	в принципе и есть, но более того, я начинал писать лабораторную на Си, где функции слегка отличаются, но функционал тот же, как же это просто, особенно на С++,
	никаких заморочек, все запускается в 3 строчки, работает гладко, главное понимать, что ты делаешь.
